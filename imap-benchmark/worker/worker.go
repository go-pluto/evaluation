package worker

import (
	"bufio"
	"fmt"

	"github.com/numbleroot/pluto-evaluation/imap-benchmark/config"
	"github.com/numbleroot/pluto-evaluation/imap-benchmark/sessions"

	"github.com/numbleroot/pluto/imap"
)

// Structs

// Session contains the user's credentials, an identifier of the session
// and a sequence of IMAP commands that has been generated by the sessions
// package.
type Session struct {
	User     string
	Password string
	ID       int
	Commands []sessions.IMAPcommand
}

// Functions

// Worker is the routine that sends the commands of the session
// to the server. The output will be logged and written in
// the logger channel. 
func Worker(id int, config *config.Config, jobs chan Session, logger chan<- []string) {
	for job := range jobs {

		var output []string
		output = append(output, "########################")
		output = append(output, fmt.Sprintf("Session: %d", job.ID))
		output = append(output, fmt.Sprintf("User: %s", job.User))
		output = append(output, fmt.Sprintf("Password: %s", job.Password))
		output = append(output, "---- starting commands ----")

		connection := dialServer(config.Server.Hostname, config.Server.Port)

		conn := &imap.Connection{
			OutConn:   connection,
			OutReader: bufio.NewReader(connection),
		}

		login(conn, job.User, job.Password, id)

		for i := 0; i < len(job.Commands); i++ {
			identifier := fmt.Sprintf("%dX%d", id, i)
			var command string

			switch job.Commands[i].Command {
			case "CREATE":
				command = fmt.Sprintf("%s CREATE %dX%s", identifier, id, job.Commands[i].Arguments[0])
				responsetime := sendSimpleCommand(conn, command)
				output = append(output, fmt.Sprintf("CREATE %d", responsetime))
				//log.Printf("creating folder\n")
			case "DELETE":
				command = fmt.Sprintf("%s DELETE %dX%s", identifier, id, job.Commands[i].Arguments[0])
				responsetime := sendSimpleCommand(conn, command)
				output = append(output, fmt.Sprintf("DELETE %d", responsetime))
				//log.Printf("deleting folder\n")
			case "APPEND":
				command = fmt.Sprintf("%s APPEND %dX%s %s %s", identifier, id, job.Commands[i].Arguments[0], job.Commands[i].Arguments[1], job.Commands[i].Arguments[2])
				responsetime := sendAppendCommand(conn, command, job.Commands[i].Arguments[3])
				output = append(output, fmt.Sprintf("APPEND %d", responsetime))
				//log.Printf("appending message\n")
			case "SELECT":
				command = fmt.Sprintf("%s SELECT %dX%s", identifier, id, job.Commands[i].Arguments[0])
				responsetime := sendSimpleCommand(conn, command)
				output = append(output, fmt.Sprintf("SELECT %d", responsetime))
				//log.Printf("selecting folder\n")
			case "STORE":
				command = fmt.Sprintf("%s STORE %s FLAGS %s", identifier, job.Commands[i].Arguments[0], job.Commands[i].Arguments[1])
				responsetime := sendSimpleCommand(conn, command)
				output = append(output, fmt.Sprintf("STORE %d", responsetime))
				//log.Printf("storing message\n")
			case "EXPUNGE":
				command = fmt.Sprintf("%s EXPUNGE", identifier)
				responsetime := sendSimpleCommand(conn, command)
				output = append(output, fmt.Sprintf("EXPUNGE %d", responsetime))
				//log.Printf("running expunge\n")
			case "CLOSE":
				command = fmt.Sprintf("%s CLOSE", identifier)
				responsetime := sendSimpleCommand(conn, command)
				output = append(output, fmt.Sprintf("CLOSE %d", responsetime))
				//log.Printf("closing folder\n")
			}
		}
		output = append(output, "########################")
		logout(conn, id)
		logger <- output
	}
}
